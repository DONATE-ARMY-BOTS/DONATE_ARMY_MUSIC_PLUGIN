import asyncio
import os
import time
from time import time

import requests
import yt_dlp
from pyrogram import filters
from pyrogram.types import Message
from youtube_search import YoutubeSearch

from DONATE_ARMY_MUSIC import app

# Define a dictionary to track the last message timestamp for each user
user_last_message_time = {}
user_command_count = {}
# Define the threshold for command spamming (e.g., 20 commands within 60 seconds)
SPAM_THRESHOLD = 2
SPAM_WINDOW_SECONDS = 5
# -------------------


# -------------------------------------------------------------------------------


@app.on_message(filters.command("song"))
async def download_song(_, message):
    user_id = message.from_user.id
    current_time = time()
    # Update the last message timestamp for the user
    last_message_time = user_last_message_time.get(user_id, 0)

    if current_time - last_message_time < SPAM_WINDOW_SECONDS:
        # If less than the spam window time has passed since the last message
        user_last_message_time[user_id] = current_time
        user_command_count[user_id] = user_command_count.get(user_id, 0) + 1
        if user_command_count[user_id] > SPAM_THRESHOLD:
            # Block the user if they exceed the threshold
            hu = await message.reply_text(
                f"**{message.from_user.mention} ·¥ò ü·¥á·¥Äs·¥á ·¥Ö·¥è…¥·¥õ ·¥Ö·¥è s·¥ò·¥Ä·¥ç, ·¥Ä…¥·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ·¥Ä“ì·¥õ·¥á Ä 5 s·¥á·¥Ñ**"
            )
            await asyncio.sleep(3)
            await hu.delete()
            return
    else:
        # If more than the spam window time has passed, reset the command count and update the message timestamp
        user_command_count[user_id] = 1
        user_last_message_time[user_id] = current_time

    query = " ".join(message.command[1:])
    print(query)
    m = await message.reply("**üîÑ s·¥á·¥Ä Ä·¥Ñ ú…™…¥…¢... **")
    ydl_ops = {"format": "bestaudio[ext=m4a]"}
    try:
        results = YoutubeSearch(query, max_results=1).to_dict()
        link = f"https://youtube.com{results[0]['url_suffix']}"
        title = results[0]["title"][:40]
        thumbnail = results[0]["thumbnails"][0]
        thumb_name = f"{title}.jpg"
        thumb = requests.get(thumbnail, allow_redirects=True)
        open(thumb_name, "wb").write(thumb.content)
        duration = results[0]["duration"]

        # Add these lines to define views and channel_name
        views = results[0]["views"]
        channel_name = results[0]["channel"]

    except Exception as e:
        await m.edit(
            "**‚ö†Ô∏è …¥·¥è  Ä·¥ás·¥ú ü·¥õs ·¥°·¥á Ä·¥á “ì·¥è·¥ú…¥·¥Ö. ·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á  è·¥è·¥ú ·¥õ è·¥ò·¥á·¥Ö ·¥õ ú·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ s·¥è…¥…¢ …¥·¥Ä·¥ç·¥á**"
        )
        print(str(e))
        return
    await m.edit("**üì• ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢...**")
    try:
        with yt_dlp.YoutubeDL(ydl_ops) as ydl:
            info_dict = ydl.extract_info(link, download=False)
            audio_file = ydl.prepare_filename(info_dict)
            ydl.process_info(info_dict)
        secmul, dur, dur_arr = 1, 0, duration.split(":")
        for i in range(len(dur_arr) - 1, -1, -1):
            dur += int(float(dur_arr[i])) * secmul
            secmul *= 60
        await m.edit("**üì§ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢...**")

        await message.reply_audio(
            audio_file,
            thumb=thumb_name,
            title=title,
            caption=f"{title}\nR·¥á«´·¥ú·¥ás·¥õ·¥á·¥Ö  ô è ‚û™{message.from_user.mention}\nV…™·¥á·¥°s‚û™ {views}\nC ú·¥Ä…¥…¥·¥á ü‚û™ {channel_name}",
            duration=dur,
        )
        await m.delete()
    except Exception as e:
        await m.edit(" - An error !!")
        print(e)

    try:
        os.remove(audio_file)
        os.remove(thumb_name)
    except Exception as e:
        print(e)


# ------------------------------------------------------------------------------- #

###### INSTAGRAM REELS DOWNLOAD


@app.on_message(filters.command(["ig"], ["/", "!", "."]))
async def download_instareels(c: app, m: Message):
    user_id = message.from_user.id
    current_time = time()
    # Update the last message timestamp for the user
    last_message_time = user_last_message_time.get(user_id, 0)

    if current_time - last_message_time < SPAM_WINDOW_SECONDS:
        # If less than the spam window time has passed since the last message
        user_last_message_time[user_id] = current_time
        user_command_count[user_id] = user_command_count.get(user_id, 0) + 1
        if user_command_count[user_id] > SPAM_THRESHOLD:
            # Block the user if they exceed the threshold
            hu = await message.reply_text(
                f"**{message.from_user.mention} ·¥ò ü·¥á·¥Äs·¥á ·¥Ö·¥è…¥·¥õ ·¥Ö·¥è s·¥ò·¥Ä·¥ç, ·¥Ä…¥·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ·¥Ä“ì·¥õ·¥á Ä 5 s·¥á·¥Ñ**"
            )
            await asyncio.sleep(3)
            await hu.delete()
            return
    else:
        # If more than the spam window time has passed, reset the command count and update the message timestamp
        user_command_count[user_id] = 1
        user_last_message_time[user_id] = current_time

    try:
        reel_ = m.command[1]
    except IndexError:
        await m.reply_text("Give me an link to download it...")
        return
    if not reel_.startswith("https://www.instagram.com/reel/"):
        await m.reply_text(
            "In order to obtain the requested reel, a valid link is necessary. Kindly provide me with the required link."
        )
        return
    OwO = reel_.split(".", 1)
    Reel_ = ".dd".join(OwO)
    try:
        await m.reply_video(Reel_)
        return
    except Exception:
        try:
            await m.reply_photo(Reel_)
            return
        except Exception:
            try:
                await m.reply_document(Reel_)
                return
            except Exception:
                await m.reply_text("I am unable to reach to this reel.")


######


@app.on_message(filters.command(["reel"], ["/", "!", "."]))
async def instagram_reel(client, message):
    user_id = message.from_user.id
    current_time = time()
    # Update the last message timestamp for the user
    last_message_time = user_last_message_time.get(user_id, 0)

    if current_time - last_message_time < SPAM_WINDOW_SECONDS:
        # If less than the spam window time has passed since the last message
        user_last_message_time[user_id] = current_time
        user_command_count[user_id] = user_command_count.get(user_id, 0) + 1
        if user_command_count[user_id] > SPAM_THRESHOLD:
            # Block the user if they exceed the threshold
            hu = await message.reply_text(
                f"**{message.from_user.mention} ·¥ò ü·¥á·¥Äs·¥á ·¥Ö·¥è…¥·¥õ ·¥Ö·¥è s·¥ò·¥Ä·¥ç, ·¥Ä…¥·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ·¥Ä“ì·¥õ·¥á Ä 5 s·¥á·¥Ñ**"
            )
            await asyncio.sleep(3)
            await hu.delete()
            return
    else:
        # If more than the spam window time has passed, reset the command count and update the message timestamp
        user_command_count[user_id] = 1
        user_last_message_time[user_id] = current_time

    if len(message.command) == 2:
        url = message.command[1]
        response = requests.post(
            f"https://lexica-api.vercel.app/download/instagram?url={url}"
        )
        data = response.json()

        if data["code"] == 2:
            media_urls = data["content"]["mediaUrls"]
            if media_urls:
                video_url = media_urls[0]["url"]
                await message.reply_video(f"{video_url}")
            else:
                await message.reply(
                    "No video found in the response. may be accountbis private."
                )
        else:
            await message.reply("Request was not successful.")
    else:
        await message.reply(
            "Please provide a valid Instagram URL using the /reels command."
        )


__MODULE__ = "S·¥è…¥…¢"
__HELP__ = """
## S·¥è…¥…¢ C·¥è·¥ç·¥ç·¥Ä…¥·¥Ös

T ú…™s ·¥ç·¥è·¥Ö·¥ú·¥á ·¥Ñ·¥è…¥·¥õ·¥Ä…™…¥s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ös  Ä·¥á·¥Ä·¥õ·¥á·¥Ö ·¥õ·¥è ·¥Ö·¥è·¥°…¥·¥è·¥Ä·¥Ö…™…¥…¢ s·¥è…¥…¢s ·¥Ä…¥·¥Ö I…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç  Ä·¥á·¥ás.

**A·¥†·¥Ä…™·¥Ä ô·¥á C·¥è·¥ç·¥ç·¥Ä…¥·¥Ös:**

- `/s·¥è…¥…¢`: D·¥è·¥°…¥·¥è·¥Ä·¥Ös ·¥Ä s·¥è…¥…¢  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥õ ú·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á·¥Ö «´·¥ú·¥á Ä è.
- `/…™…¢`: D·¥è·¥°…¥·¥è·¥Ä·¥Ös ·¥Ä…¥ I…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç  Ä·¥á·¥á  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥õ ú·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á·¥Ö …™…¥·¥ã.
- `/ Ä·¥á·¥á`: D·¥è·¥°…¥·¥è·¥Ä·¥Ös ·¥Ä…¥ I…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç  Ä·¥á·¥á  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥õ ú·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á·¥Ö …™…¥·¥ã.

**N·¥è·¥õ·¥á:**
- T·¥è ·¥Ö·¥è·¥°…¥·¥è·¥Ä·¥Ö ·¥Ä…¥ I…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç  Ä·¥á·¥á, ·¥ò Ä·¥è·¥†…™·¥Ö·¥á ·¥Ä ·¥†·¥Ä…™·¥Ö I…¥s·¥õ·¥Ä…¢ Ä·¥Ä·¥ç  Ä·¥á·¥á URL ·¥ús…™…¥…¢ ·¥õ ú·¥á `/…™…¢` ·¥è Ä `/ Ä·¥á·¥á` ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö.
- T ú·¥á  ô·¥è·¥õ ·¥°…™  ú·¥Ä…¥·¥Ö·¥á s·¥ò·¥Ä·¥ç·¥ç…™…¥…¢  ô è …™·¥ç…™·¥õ…™…¥…¢ ·¥õ ú·¥á …¥·¥ú·¥ç ô·¥á Ä ·¥è“ì ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ös ·¥ò·¥á Ä ·¥ús·¥á Ä ·¥°…™·¥õ ú…™…¥ ·¥Ä s·¥ò·¥á·¥Ñ…™“ì…™·¥Ñ ·¥õ…™·¥ç·¥á ·¥°…™…¥·¥Ö·¥è·¥°.
"""
